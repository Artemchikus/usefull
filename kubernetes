Ресурсы кластера согласно Kubernetes API:
Pod - базовый объект, который используется для запуска контейнеров на Node'ах. Контейнеры, создаются с помощью Dockerfile'ов и не только. Внутри одного Pod'а может находится несколько контейнеров, которые будут иметь общий доступ к таким ресурсам, как Volume'ы и сетевой стек, что удобно в некоторых случаях, но в основном внутри одного Pod'а находится один основной контейнер и может еще контейнер для сбора метрик. В ручную контейнеры в Kubernetes никто не создает
ReplicaSet - объект, являющийся ReplicationController'ом маминой подруги и в будущем должен его полностью заменить, предназначен для автоматического управления Pod'ами, а именно он позволяет поддерживать заданное админом количество Pod'ов не смотря ни на что, то есть ReplicaSet автоматически поднимет заданное количество Pod'ов и при отказе одного из них создаст недостающий Pod, а неисправный остановит и удалит. Pod'ы выбираются в ReplicaSet с помощью меток, как и в ReplicationController, но у ReplicaSet расширенный функционал селектора меток (единственное отличие).
ReplicationController - объект, предназначен для автоматического управления Pod'ами, является клоном ReplicaSet, но хуже, так что лучше использовать ReplicaSet.
Deployment - объект предназначенный для развертывания и обновления ReplicaSet, позволяет настроить процесс развертывания Pod'ов, а именно сколько Pod'ов могут разворачиваться одновременно, сколько Pod'ов могут быть недоступны одновременно, после чего можно например изменить образ Pod'а в манифесте и Deployment автоматически будет удалять по одному старому Pod’у и плавно заменять их новыми (при одной из настроек), тем самым доступность приложения не падает.
Service - объект предназначенный для предоставления общего IP адреса нескольким одинаковым(имеют одинаковый набор меток) Pod'ам. Например вы (или предназначенные для этого ресурсы) для увеличения доступности распихали ваши Pod'ы по Node'ам в разных концах света, естественно каждый Pod работает на разных портах разных Node, Service в свою очередь предоставляет одну точку входа для всех запросов, а потом равномерно распределяет их между Pod'ами, что удобно, ведь это работает даже при обмене запросов внутри Cluster'a. Также если ваш Pod упадет, есть вероятность, что он восстановится уже на другой Node, IP адрес изменится, но Service его не потеряет.
   Типы:
      LoadBalancer - тип Service, при котором Pod'ы подключенные к сервису доступны по единому IP адресу извне, обычно предоставляется облачными провайдерами, но есть бесплатное решение для голого железа под названием MetalLB. Самый крутой тип для публичных сервисов, ведь можно самостоятельно настраивать балансировку нагрузки между Pod'ами.
      NodePort - тип Service, при котором Pod'ы подключенные к сервису доступны по единому порту IP адреса любой Node'ы, то есть доступ к Service осуществляется, черезе IP адрес любой Node'ы + забинженный единый порт. Доступ извне как не трудно догадаться присутствует.
      ClusterIP - тип Service, при котором Pod'ы подключенные к сервису доступны по единому IP только внутри Cluster'а. Если не хочется все плюшки Service, но без доступа к Pod'ам извне.
      ExternalName - тип Service, при котором DNS имя уже созданного Service на DNS сервере Kubernetes мапится на другое DNS имя, так что при запросе на DNS сервер по новому DNS имени, запрос перенаправляется по старому имени. Честно говоря сам не знаю для чего это используется.
Node - объект представляющий из себя сервер, на котором будут запускаться ваши Pod'ы. Обычно должно быть как минимум 3 Master Node'а (узлы управления Cluster’ом, на них например хостится API server) и 3+ Worker Node'ов (узлы, на которых лежат рабочие Pod'ы).
ConfigMap - объект, который позволяет разделять конфигурационные файлы и контейнеры с приложениями, избавляя от необходимости упаковывать конфиги в docker-образ. ConfigMap можно монтировать в файловую систему Pod'а, а также использовать значения ConfigMap для задания ENV переменных и аргументов в манифестах Pod'ов.
Secret - объект, похожий на ConfigMap, но предназначенный для хранения конфиденциальной информации, такой как пароли, OAuth-токены или ssh-ключи. Та же функциональность, но все значения ключей кодируются в base64.
StatefulSet - объект, который используется для управления приложениями и отслеживания их состояния. Другими словами это ReplicaSet, но если Pod, созданный ReplicaSet при удалении и создании получает новое DNS-имя, IP-адрес и теряет все, что было сохранено в файловую систему Pod'а, то при использовании StatefulSet после перезапуска Pod'а все это сохраняется, а также PersistentVolumeClaim, ведь нормально использовать PersistentVolumeClaim для каждого Pod'а в ReplicaSet не получится.
DaemonSet - объект, который используется для размещения Pod'ов по Node'ам, гарантирует что на Node'ах с соответствующими метками будут размещены данные Pod'ы. Например для сбора метрик Node'ов.
HorizontalPodAutoscaler - объект предназначенный для автоматического масштабирования количества Pod'ов, в зависимости от потребляемых ими ресурсов(CPU или Memory) или кастомных метрик. Не будет работать, если на API-сервер не будут приходить метрики, поэтому необходимо реализовать сборщика и приемщика этих метрик, одна из реализаций cAdvizor + Metrics Server. Для кастомных метрик можно использовать NodeExporter + Promtheus + Kube-State-Metrics + Prometheus Adapter.
PersistentVolume - объект представляющий собой постоянный том (Persistent Volume), который можно монтировать в Pod'ы с помощью PersistentVolumeClaim, тем самым сохраняя информацию после отказа или перезапуска Pod'a.
PersistentVolumeClaim - объект, являющийся заявкой на PersistentVolume, который помогает абстрагировать программиста, которому просто нужно хранилище данных от админа, которыми этими хранилищами ворочает. Простыми словами программист составляет манифест PersistentVolumeClaim, что ему нужно хранилище на 50Гб, и ему автоматически предоставляется PersistentVolume, соответствующее критериям или лучше (например на 100Гб, если на 50Гб нет). Если свободного PersistentVolume нет, то Pod будет находится в режиме ожидания, но есть PersistentVolume Provisioners, как от облачных вендоров, так и от сообщества, реализующие автоматическое создание PersistentVolume по PersistentVolumeClaim, например GlusterFS + Heketi.
StorageClass - объект, который предоставляет возможность разделить хранилища на классы с определенными параметрами, на основе которых потом будут составляться PersistentVolume. StorageClass может предоставляться облачным вендором, а также его может создать пользователь, для описания своего собственного хранилища.
Ingress - объект, который предоставляет возможность доступа к разным сервисам внутри Cluster’а по одному DNS имени, например my-site.com/frontend будет перенаправлять все запросы в frontend Pod'ы, а my-site.com/backend будет перенаправлять все запросы в backend Pod'ы, что удобно когда у вас много микросервисов. Не работает без Ingress Controller, например Ingress-Nginx, и без настроенного LoadBalancer.
IngressClass - объект, который представляет собой аналог StorageClass для Ingress Controller'ов, позволяет связывать объекты Ingress c Ingress Controler'ами, а также передавать дополнительные параметры конфигурации Ingress'ам.
Namespace - объект, который предоставляют область имен для ресурсов для разделения ресурсов Cluster'a между пользователями(не только User'ы, но и процессы внутри Pod'ов например) для удобства и кончено безопасности, так как большинство ресурсов видят только в пределах своего Namespace, если конечно не обращаются к общему для всего Cluster'a DNS серверу. Также удобно, что при удалении Namespace все ресурсы, которые в нем находились тоже удалятся.
ServiceAccount - объект, который позволяет предоставить идентификатор, используя который ресурсы Cluster'а, а точнее процессы внутри этих ресурсов, могут быть идентифицированы и авторизованы для выполнения запросов к API-серверу Kubernetes. Их можно связывать с Role'ами для предоставления различных прав при общении с API-сервером. С точки зрения абстракции похож на StorageClass и IngressClass.
Role - объект, который описывает набор прав на ресурсы Cluster'а, но в пределах Namespace, в котором находится ресурс.
RoleBinding - объект, который связывает Role и ресурс Cluster'а, то есть у нескольких ресурсов может быть одна Role. Если связать ClusterRole через RoleBinding, то ресурс получит права только внутри Namespace, что удобно ведь можно создать одну общую ClusterRole, которую можно связывать RoleBinding в нескольких Namespace, вместо создания Role в каждом из этих Namespace'ов.
ClusterRole - объект, который описывает набор прав на ресурсы Cluster'а, но в отличии от Role, как в родном Namespace, так и по всему Claster'у.
ClusterRoleBinding - объект, который аналогично RoleBinding, связывает CluserRole и ресурс Cluster'а.
LimitRange - объект, который отслеживает выставление значений реквестов/лимитов по ресурсам для всех Pod’ов в Namespace’е. Используется для того, чтобы отдельно взятый Pod не хапал CPU или Memory больше положенного админом.
ResourceQuota - объект, который ограничивает суммарное количество ресурсов, которое могут запросить все ресурсы в Namespace'е. Используется для того, чтобы совокупность Pod'ов в Namespace не хапала больше чем положенного (отдельно взятый Pod никак не контролируется, он может один хоть все место занять в Namespace'е, главное чтоб не больше ResourceQuota).
Job - объект, который создаёт Pod для выполнения разовой задачи. Если запуск задачи завершается с ошибкой, Job перезапускает Pod’ы до успешного выполнения или до истечения тайм аутов. Когда задача выполнена, Job считается завершенным и больше никогда в Cluster’е не запускается.
CronJob - объект, который по расписанию создает Job'ы.
Endpoints - объект, который связывает Pod'ы и Service'ы, содержит в себе список IP адресов Pod'ов которые принадлежат Service'у. Обычно создается автоматически, но можно создать кастомный Endpoints.
EndprointsSlice - объект, содержащий в себе сисок различных Endpoints'ов, для более удобного наблюдения за всеми Endpoints'ами в Cluster'е.
CSIDriver - объект, который представляет собой драйвер связывающий Container Storage Interface (унифицированный интерфейс, который описывает взаимодействие системы управления контейнерами и специального драйвера) и Систему Хранения Данных, которую может представлять облачный вендор, тогда CSIDriver уже написан за вас, или ваша собственная Система Хранения Данных, но в таком случае нужно будет написать свой CSIDriver, в таком случае нужно будет написать Node Plugin (отвечает за монтирование Volume'ов и за операции на них) и Controller Plugin (создает или удаляет Volume'ы, назначает права доступа и т. д.). Next Big Thing Kubernetes.
VolumeAttachment - объект, который описывает информацию, относящуюся к монтированию и размонтированию Volume при использовании Pod'а. В зависимости от статуса VolumeAttachment External-attacher выполняет операции монтирования и размонтирования Volume'ов. Другими словами хранит в себе инфу дали ли PV по PVC. Обычно создается автоматически.
CSINode - объект, который хранит информацию о Node в Cluster'е для Container Storage Interface. Container Storage Interface будет работать только с теми Node'ами, которые есть в списке CSINode.
CSIStorageCapasity - объект, который содержит информацию о емкости для одного StorageClass и определяет, какие Node'ы имеют доступ к этому StorageClass. Обычно создается CSIDriver'ом.
ControllerRevision - объект, который хранит в себе снимок состояния при обновлении Deployment, DaemonSet и StatefulSet, чтобы можно было откатиться к старой версии. Обычно создается контроллерами стоящими за этими ресурсами.
CustomResourceDefinition - объект, который позволяет добавлять новые типы ресурсов в API Kubernetes, не изменяя исходный код Kubernetes или создавая собственный сервер API, если ресурсов из коробки не хватает.
Event - объект, который показывает, что происходит в Cluster’е при изменении состояния или ошибках, вызванных другими ресурсами системы. Создается автоматически всеми ресурсами Cluster'a.
MutatingWebhookConfiguration - объект, который описывает конфигурацию и прием webhook'ов, которые принимают или отклоняют и могут изменять объект. С помощью MutatingWebhookConfiguration вы теоретически можете прослушивать и изменять запросы на изменение объектов, обрабатываемые ApiServer.
ValidatingWebhookConfiguration - объект, который описывает конфигурацию и прием webhook'ов, которые принимают или отклоняют объект без его изменения. С помощью ValidatingWebhookConfiguration вы теоретически можете прослушивать и изменять запросы на получение информации об объектах, обрабатываемые ApiServer.
PodTemplate - объект, который описывает шаблон Pod'а. Таким образом можно создать один PodTemplate, а потом использовать его в ресурсах разворачивающих Pod'ы (Deployment и т. д.), чтобы каждый раз не писать одну и то же описание Pod'а.
PodDistributionBudget - объект, который задает количество Pod'ов определенных меток, которые должны продолжать работать даже при выходе Node'ы из строя. В основном используется при миграции Pod'ов с старой Node'ы на новую (с помощью команды Drain, которая помечает Node'у как вышедшую из строя), чтобы сохранялась доступность приложений, если не создавать PodDistributionBudget то сначала все Pod'ы старой Node'ы остановятся, и только потом перенесутся, что сделает приложения работающие на данных Pod'ах временно недоступными.
PriorityClass - объект, который связывает приоритетность Pod'a с самим Pod'ом. Схож со StorageClass и т. д. и используется для удобного деления Pod'ов на группы по приоритетам, а также для безопасности ведь Джуны могут ставить своим Pod'ам высокие приоритеты, тем самым например вытесняя все нужные Pod'ы с высокопроизводительных Node'ов. Чем выше приоритет Pod'а тем дальше он в очереди на вытеснение (если на Node нет свободного места, а туда планировщиком назначен Pod, то какой-то старый Pod останавливается и переносится на другую Node'у) с Node'ы.
PodSecurityPolicy - объект, который обеспечивают точную авторизацию создания и обновлений Pod'ов, другими словами PodSecurityPolicy определяют набор условий, с которыми должен работать модуль, чтобы быть принятым в систему, а также значения по умолчанию для связанных полей. Используется для обеспечения безопасности, но устареет уже в версии 1.25 Kubernetes, кго заменит Pod Security Admission
APIService - объект, который позволяет расширить API-сервер Kubernetes дополнительными API, которые не являются частью основных API Kubernetes. Например для работы HorizontalPodAutoscaler нужно расширение для API-сервера Kubernetes под названием custom-metrics-apiserver, которое создает prometheus-adapter или вы (см. официальную документацию на английском). Удобный фреймворк - Kubebuilder.
CertificateSigningRrequest - объект, который обеспечивают механизм получения сертификатов x509 путем подачи запроса на подписание сертификата, его асинхронного одобрения и выдачи. Пользователь генерирует закрытый ключ RSA (обычно с помощью openssl), далее генерирует (с помощью файла конфигурации и openssl) запрос на подпись сертификата (CSR, как и название ресурса), после чего CSR отправляется админам, которые на его основе создают (примерно в 3 шага) ресурс CretificateSigningRrequest, который будет использоваться для аутентификации запросов, который пользователь отправит на сервер API.
FlowSchema - объект, который сопоставляет некоторые входящие запросы приходящие на API-сервер Kubernetes с PriorityLevelConfiguration. Запрос, приходящий на API-сервер, сначала оценивается на соответствие одной из схем потоков (FlowSchema), после чего FlowSchema назначает запросу уровень приоритета, что помогает бороться с ситуациями, когда низкоприоритетный трафик душит критически важные вызовы. Трафик делится по потокам (например запросы из одного источника в один поток) и уровням приоритета (ограничивать только запросы с определенным уровнем приоритета).
PriorityLevelConfiguration - объект, который определяет конфигурацию уровня приоритета, например долю параллелизма или стратегию обработки очереди запросов. Если FlowSchema просто сортировала запросы, то PriorityLevelConfiguration уже регулирует трафик внутри определенного потока (FlowSchema).
Lease - объект, предназначенный для определения живости Node'ы. Обычно создается Kubelet, после чего обновляется каждые 10 секунд (а именно поле acquireTime), если объект обновился неудачно, то с Node'ой какая-то проблема. Люди ворде как его не создают.
SubjectAccessReview - объект, который проверяет, может ли пользователь или группа выполнить действие. После отправки yaml на API-сервер Kubernetes, поле status SubjectAccessReview будет указывать, может ли пользователь или группа выполнить действие.
LocalSubjectAccessReview - объект, который проверяет, может ли пользователь или группа выполнять действие в данном Namespace. Принцип работы как у SubjectAccessReview, но только проверка осуществляется внутри одного Namespace.
SelfSubjectAccessReview - объект, который проверяет, может ли пользователь (или ресурс), отправивший yaml файл выполнять действие в данном Namespace или вообще. Принцип работы как у SubjectAccessReview, но только проверка осуществляется для самого себя.
SelfSubjectRulesReview - объект, который возвращает набор действий, которые пользователь может выполнять в Namespace. Принцип работы как у SubjectAccessReview, но только осуществляется не проверка, а просто возвращаются (в status.resourceRules.verbs) разрешенные действия для User'а.
RuntimeClass - объект, с помощью которого можно выбрать среду выполнения контейнера. Если считаешь, что дефолтная среда выполнения не достаточно безопасная. Хайповая среда выполнения - gVisor.
TokenRequest - объект, который запрашивает токен для данного ServiceAccount. Принцип работы схож с SubjectAccessReview, в поле status будет информация о выдаче токена (сам токен и на какой период времени).
TokenReview - объект, который проверяет принадлежит ли данный токен данному User'у и ServiceAccount'у. Принцип работы схож с SubjectAccessReview, в поле status будет информация связан ли токен, а также информация о User'е или ServiceAccount'е. Придуман, чтоб Pod'ы друг друга идентифицировали.
NetworkPolicy - объект, который описывает, какой сетевой трафик разрешен для данного набора Pod'ов. Если быть точным, то в NetworkPolicy блокируются IP-адреса, типы протоколов, порты, Nammespace'ы и Pod'ы, на которые Pod может слать запросы, и от которых Pod может получать запросы. По дефолту Pod может отправлять запросы кому хочет и получать запросы от кого хочет.

Команды:
kubectl config view - объединённые настройки kubeconfig
kubectl config get-contexts - список контекстов
kubectl config current-context - текущий контекст
kubectl config use-context <имя кластера> - установить имяконтекст по умолчанию
kubectl config set-credentials <пользователь> --username=<логин> --password=<пароль>
kubectl config set-context --current --namespace=<пространство имен> - задать пространство имен для текущего контекста
kubectl config unset <пользователь> - удалить пользователя
kubectl explain <ресурс> - документация по ресурсу
kubectl apply -f <yaml файл> - внести изменения в параметры ресурса из yaml файла
kubectl create -f <yaml файл> - создание ресурса с помощью yaml файла
kubectl api-resources - список всех ресурсов Kubernetes
kubectl get <тип ресурса> - список ресурсов опредленного типа
   --all-namespaces - для всех пространств имен
   -o wide - подробно
   <имя ресурса> - конкретный созданный ресурс (например определенный Pod)
   -o yaml - в виде yaml файл
   --sort-by=<параметр> - сортировка по параметру
   --selector=<метка> - с определенной меткой
   --field-selector=<поле=значение> - с определенным значением поля
   --show-labels - список меток
   -o custom-columns=<список столбцов> - только определенные столбцы
kubectl describe <тип ресурса> <имя ресурса> - сведения о конкретном созданном ресурсе
kubectl diff -f <yaml файл> - сравнение текущего состояния кластера с состоянием, в котором находился бы кластер в случае применения манифеста
kubectl set <тип поля> <тип ресурса>/<имя ресурса> <имя контейнера>=<новое значение> - обновление параметра контейнеров внунтри ресурсов (Pod, ReplicationController, Deployment, Daemonset, StatefulSet, CronJob, ReplicaSet)
   Типы полей:
       env - переменная окружения
       image - родительский образ
       resources - лимиты ресурсов или запросы на ресурсы (--limits=<лимиты> --requests=<запросы>)
       selector - метка
       serviceaccount - ServiceAccount
kubectl set subject <тип ресурса> --serviceaccount=<ServiceAccount> --user=<имя> --group=<группа> - обновление параметров специфических ресурсов (ClusterRoleBinding и RoleBinding)
kubectl rollout history <тип ресурса>/<имя ресурса> - история ресурса, включая ревизии
kubectl rollout undo <тип ресурса>/<имя ресурса> - откатиться к предыдущему состоянию ресурса
kubectl rollout status -w <тип ресурса>/<имя ресурса> - отслеживание статуса ресурса
kubectl rollout restart <тип ресурса>/<имя ресурса> - перезапуск ресурса ресурса
kubectl replace -f <yaml файл> - заменить (пересоздать) ресурс
   --force - принудительно
kubectl expose <тип ресурса> <имя ресурса> --port=<порт Service> --target-port=<порт контейнера> - создать Service для ресурса
kubectl label pods <имя Pod'a> <метка> - добавление метки Pod'у
kubectl annotate pods <имя Pod'a> <аннотация> - добавление аннотации Pod'у
kubectl autoscale <тип ресурса> <имя ресурса> --min=<минимум копий> --max=<максимум копий> - настройка автоматического масштабирования специализированных ресурсов (Deployment, ReplicaSet, StatefulSet, ReplicationController)
kubectl patch <тип ресурса> <имя ресурса> -p <json строка> - обновление поля ресурса с помощью json строки
   --type='json' - если надо изменить несколько полей (json строка включает массив)
   -f <yaml файл> - с помощью yaml файла
kubectl edit <тип ресурса> <имя ресурса> - редактирование yaml файла ресурса в etcd
   -f <yaml файл> - с помощью yaml файла
kubectl scale --replicas=<количество копий> <тип ресурса> <имя ресурса> - увеличение количества копий ресурса
kubectl delete <тип ресурса> <имя ресурса> - удаление ресурса
   -l <метка> - определенной метки
   -f <yaml файл> - описанного в файле
   -n <пространство имен> - в определенном пространстве имен
kubectl logs <имя Pod'а> - логи Pod'a
   -l <метка> - определенной метки
   -c <имя контейнера> - определенного контейнера
   -f - режим реального времени
kubectl run <имя> --image=<родительский образ> --restart=<действие при отключении> -n mynamespace - запуск Pod'а (лучше все таки с помощью yaml файла)
kubectl attach <имя Pod'a> -i - подключиться к запущенному контейнеру
kubectl port-forward <имя Pod'a> <локальный порт>:<порт Pod> - переадресация порта в локальной машине на порт в Pod'е
kubectl exec <имя Pod'a> -- <команда> - выполнить команду в Pod’е (если один контейнер)
kubectl exec <имя Pod'a> -c <имя контейнера> -- <команда> - выполнить команду в конкретном контейнере Pod'a
kubectl exec -ti <имя Pod'a> /bin/bash - запустить /bin/bash в Pod'е
kubectl top node <имя узла> - вывод метрик узла
kubectl top pod <имя Pod'a> - вывод метри Pod'а
   --containers - с метриками по каждому контейнеру
kubectl cordon <имя узла> - отметить узел как не назначаемый
kubectl drain <имя узла> - опустошение узла (вытеснение всех Pod'ов с узла на другие)
kubectl uncordon <имя узла> - отметить узел как назначаемый
kubectl cluster-info - информация о кластере
kubectl api-versions - доступные версии API
kubectl rolling-update <имя ReplicationController> -f <yaml файл> - постепенная замена указанного ReplicationController'a и его Pod'ов согласно новым параметрам из yaml файла
kubectl wait --for=<состояние> <тип ресурса>/<имя ресурса> - ожидание определенного состояния ресурса
kubectl auth can-i <действие> <тип ресурса> - проверка на разрешение выполнить действие с ресурсом
kubectl auth can-i --list - список доступных действий
kubectl auth reconcile -f <yaml файл> - согласовние RBAC с помощью файла (изменение разрешений для Role, RoleBinding, ClusterRole, ClusterRoleBinding)
kubectl cp <файл> <имя Pod'а>:<путь> - копирование файлов в/из контейнеров
   -c <имя контейнера> - определенный контейнер
kubectl events - список событий