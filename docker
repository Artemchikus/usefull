Инструкции:
FROM - задает базовый образ для последующих инструкций. Можно использовать любой работающий образ, проще всего начать с загрузки образа из публичного репозитория. Пустой образ - "scratch". Обычно является первой инструкцией, но может идти после ARG, чтобы например использовать имя образа из аргументов команды сборки контейнера (${имя аргумента}). Также FROM может использоваться несколько раз внутри одного Dockerfile, например для уменьшения размера конечного контейнера.
    Шаблоны ввода:
    • <образ>
    • <образ>:<тэг> (тэг - конкретная версия образа, по умолчанию "latest")
    • <образ>@<дайджест> (дайджест - хэш образа, если в образе что-то поменяют, то и хэш изменится)
    • <образ>:<тэг>@<дайджест> (пример - ubuntu:20.04@sha256:8bce67040cd0ae39e0beb55bcb976a824d9966d2ac8d2e4bf6119b45505cee6)
Также после любого из  шаблонов можно добавить инструкцию "AS <имя>" для изменения имени образа.
RUN - выполняет любые команды в новом слое поверх текущего образа и делает коммит результата. Как можно понять создает слой с каждой новой инструкцией. Полученный после коммита образ будет использован для следующего  шага в Dockerfile.
    Шаблоны ввода:
    • <команда>; <команда> (команды базовой оболочки Linux или Windows)
    • ["исполняемый файл", "параметры"...] (Исполнение файла с параметрами, если нужна команда не базовой оболочки)
Есть поддержка выполнения нескольких команд внутри одного RUN, перенося их на следующую строку через "\" и <Enter> естественно, и это хоро шая практика, так как в таком случае не создаются новые слои. Если надо сменить базовую оболочку предварительно используйте инструкцию SHELL.
CMD - задает команду или исполняемый файл с параметрами по умолчанию, который(ая) будет выполнен(а) при запуске контейнера, также можно опустить исполняемый файл, но в этом случае вы должны использовать инструкцию ENTRYPOINT. RUN - работает во время сборки, CMD - при запуске.
    Шаблоны ввода:
    • <команда> <параметры>... (команда оболочки, которая выполнится при запуске контейнера)
    • ["исполняемый файл", "параметры"...] (файл, который запускается с заданными параметрами при запуске контейнера)
    • ["параметры"...] (параметры запуска, которые будут переданы инструкции ENTRYPOINT)
Аргументы переданные при запуске контейнера могут переопределять параметры по умолчанию, в том числе и исполняемый файл, поэтому для обозначения исполняемого файла лучше использовать ENTRYPOINT. В Dockerfile следует задать хотя бы одну из команд CMD или ENTRYPOINT.
LABEL - Добавляет метаданные(например размер контейнера или имя автора) с именем <ключ> и значением <значение> для образа. Раньше создавала новый слой теперь нет, так что можно не париться и добавлять новые лейблы через дублирование инструкции, в отличие от RUN, где это не приветствуется. Если Docker встречает лейбл который уже существует, то старое значение будет заменено новым.
    Шаблоны ввода:
    • <ключ>="<значение>" (лучше все значения писать в "", будет меньше проблем)
EXPOSE - указывает Docker что контейнер слу шает определенные порты после запуска. EXPOSE не делает порты контейнера доступными для хоста, но это уже проблема оркестратора (если кратко то проты контейнера еще нужно пробросить на порты хоста, чтобы можно было работать с приложениями внутри контейнера извне).
    Шаблоны ввода:
    • <порт> (порт, на котором работает ваше приложение внутри контейнера)
    • <port>/<protocol> (порт вместе с протоколом UDP или TCP, TCP - дефолтный)
Можно объявить сразу несколько портов через пробел, но EXPOSE не создает слоев, так что зачем, просто дублируем инструкцию для лучшей читаемости.
ENV - задает переменные окружения с именем <ключ> и значением <значение>. Эти значения будут находиться в окружении всех команд потомков Dockerfile и могут быть использованы как обычные переменные окружения. Значение будет интерпретировано для других переменных среды, поэтому символы кавычек будут удалены, если они не экранированы. Переменные окружения сохраняться и после сборки контейнера, так что если по какой-то причине этого не хочется, то можно запихнуть ENV внутрь RUN (RUN <ключ>=<значение> <команда>), где она исчезнет после выполнения команды.
    Шаблоны ввода:
    • <ключ>=<значение> (имя и значение переменной окружения)
Можно инициализировать в одной инструкции несколько переменных окружения, но ENV не создает слоя, так что не вижу в этом смысла, смело дублируем инструкции.
ADD - копирует новые файлы, папки или удаленные файлы по URLs из <откуда> и добавляет их в файловую систему контейнера в <куда> (абсолютный, если перед <куда> есть "/", или относительный путь при использовании WORKDIR, если перед <куда> нет "/"), СТОП но это же COPY маминой подруги. Но будь проклят тот, кто использует ее для обычного копирования локальных файлов, ведь для этого есть COPY, лучшие практики что сказать.
    Шаблоны ввода:
    • <откуда> <куда> (<откуда> может быть URL или сжатый архив, с остальным пожалуйста к COPY)
    • <откуда>... <куда>/ (несколько источников файлов, также есть поддержка групповых символов (wildcards), <куда> должен быть каталогом и оканчиваться "/")
ADD не поддерживает аутентификацию, с этим идем к RUN curl и тд. Если <откуда> является URL и <куда> заканчивается слешем, то имя файла берется из URL и файл скачивается в <куда>/<имя файла>. Также сам каталог <откуда> не копируется, только его содержимое. Локальный сжатый архив распакуется, а вот по URL - нет. При отсутствии <куда> он создастся. Создает новый слой, так что добавляем по-минимуму.
COPY - инструкция COPY копирует новые файлы или каталоги из <откуда> и добавляет их в файловую систему контейнера в <куда> (абсолютный, если перед <куда> есть "/", или относительный путь при использовании WORKDIR, если перед <куда> нет "/").
    Шаблоны ввода:
    • <откуда> <куда> (<откуда> должен находится внутри контекста сборки, то есть не выше каталога, в котором лежит Dockerfile)
    • <откуда>... <куда>/ (несколько источников файлов, также есть поддержка групповых символов (wildcards), <куда> должен быть каталогом и оканчиваться "/")
Если <откуда> - каталог, то копируется содержимое каталога, а не сам каталог. Если <куда> не заканчивается слешем, он будет рассматриваться как обычный файл и содержимое <откуда> будет записано в <куда>. При отсутствии <куда> он создастся. Создает новый слой, так что копируем по-минимуму.
ENTRYPOINT - позволяет настроить контейнер так чтобы он работал как исполняемый файл.Тот же самый функционал как у CMD, но CMD используют в основном для передачи параметров в ENTRYPOINT или для исполнения команды по умолчанию в оболочке, другими словами бинарник выбираем в ENTRYPOINT, а с помощью CMD выполняем команды. Обе инструкции выполняются во время запуска контейнера, не во время сборки.
    Шаблоны ввода:
    • ["<исполняемый файл>", "<параметры>"...] (предпочтительная форма)
    • command param1 param2 (фу такую форму использовать)
Только последняя инструкция ENTRYPOINT из Dockerfile будет запущена, но CMD, если в ней указан исполняемый файл или команда, тоже запустится, но лучше таким не заниматься. В Dockerfile следует задать хотя бы одну из команд CMD или ENTRYPOINT. Если CMD определяется из базового образа (после FROM), установка ENTRYPOINT сбросит CMD до пустого значения.
VOLUME - создает точку монтирования с заданным именем и помечает его как внешний смонтированный том из базового хоста или контейнера. Таким образом можно например сохранять данные БД, которая находится внутри контейнера в файловой системе хоста, ведь контейнер создается с ограниченным свободным местом и все внутренние данные теряются при перезапуске.
    Шаблоны ввода:
    • ["/<точка монтирования>"]
    • /<точка монтирования> (предпочтительней)
Можно описать несколько точек монтирования в одной инструкции, но слой не создается, так что лучше дублировать инструкцию.
USER - устанавливает имя пользователя (UID) от имени которого будет запущен образ, а также инструкции RUN, CMD и ENTRYPOINT содержащиеся в Dockerfile. Понятно, что пользователь перед этим должен быть создан.
    Шаблоны ввода:
    • "<имя>"
WORKDIR - устанавливает рабочий каталог для всех инструкций RUN, CMD, ENTRYPOINT, COPY и ADD которые будут выполнены в Dockerfile. Если WORKDIR не задана, то она будет создана даже если в Dockerfile нет ни одной инструкции для которой это необходимо. Инструкция может быть использована несколько раз в одном Dockerfile. Если указывается относительный путь, он будет определен относительно предыдущего значения WORKDIR.
    Шаблоны ввода:
    • /<рабочий каталог> (если не пишется "/", то WORKDIR поменяется относительно старого WORKDIR, в первом WORKDIR и при задании абсолютного пути использовать "/" перед названием каталога)
Инструкция WORKDIR может использовать переменные окружения заданные через ENV (${ИМЯ}).
ARG - задает переменные которые пользователь передает сборщику образа, аргументы передаваемые при инициализации сборки контейнера (docker build).
    Шаблоны ввода:
    • <имя>=<значение по умолчанию> (задается значение по умолчанию, которое будет использовать сборщик, если ничего не передали, предпочтительно)
    • <имя> (просто инициализация переменной)
Не рекомендуется использовать в переменных сборки секретные ключи например от github, учетные данные пользователя и т. д. Переменные окружения заданные с помощью ENV всегда заменяют переменные с тем же именем заданные инструкцией ARG. Docker имеет набор предустановленных переменных ARG которые вы можете задавать без предварительной инструкции ARG в Dockerfile (гуглите сами). Переменные ARG не сохраняются в собранном образе в отличии от ENV переменных.
ONBUILD - добавляет к образу триггерную инструкцию, которая выполняется в последнюю очередь если образ используется в качестве базового для другой сборки. Триггер будет выполнен в дочернем контексте сборки, так если бы инструкция была вставлена сразу после инструкции FROM дочернего Dockerfile. Это полезно если вы собираете образ который будет использоваться в качестве базового для сборки другого образа, например вы можете изменить переменные окружения или сделать демон конфигурация которого может быть изменена пользователем.
    Шаблоны ввода:
    • <имя инструкции> <что обычно после данной инструкции> (например RUN ls)
Цепи инструкций ONBUILD ONBUILD и ONBUILD FROM не допускаются. Инструкция внутри ONBUILD не оказывает влияния на текущую сборку. В дочернем образе ONBUILD функционирует как часть обработки инструкции FROM, сборщик ищет ONBUILD триггеры и выполняет их в том же порядке в котором они были добавлены. Если один из триггеров вызывает ошибку, инструкция FROM обрывается и вызывает ошибку сборки. Если все триггеры отработали, инструкция FROM завер шается и сборка продолжается как обычно, а также дочерние образы не унаследуют триггеры прародителей. Не создает новый слой, так что дублируем инструкции.
STOPSIGNAL - устанавливает сигнал системного вызова, который будет отправлен для завершения контейнера. Сигнал может быть натуральным числом, которое соответствует позиции в таблице системных вызовов ядра, например 9 или именем сигнала в формате SIGNAME, например SIGKILL. Мало когда используется по-моему.
    Шаблоны ввода:
    • <натуральное число>
    • <SIGNAME> (заглавными буквами)
HELATHCHECK - указывает Docker как проверить работает ли контейнер. Данная функция может помочь в выявлении ситуаций когда веб-сервер вошел в бесконечный цикл и не принимает соединения, в то время как его процесс все еще работает.
    Шаблоны ввода:
    • [опции...] <CMD команда> (слово CMD обязательно, опции:  --interval=<время между проверками> (по умолчанию: 30s);  --timeout=<время, после которого проверка является неудачной> (по умолчанию: 30s);  --retries=<допустимое количество неудачных проверок> (по умолчанию: 3))
    • <CMD команда>
    • NONE (явно указываем, что проверка не нужна)
Когда у контейнера задана проверка на работоспособность, он имеет дополнительный статус состояния. Этот статус изначально равен starting. Всякий раз когда проверка состояния проходит успешно, он становится равен healthy (вне зависимости от предыдущего состояния). После определенного числа неудачных проверок статус изменяется на unhealthy. Дальше уже проблема оркестратора.
SHELL - позволяет заменить стандартную оболочку для выполнения команд на пользовательскую. Оболочкой по умолчанию в Linux является ["/bin/sh", "-c"], а в Windows ["cmd", "/S", "/C"]. Может использоваться несколько раз, заменяя предыдущую инструкцию SHELL, и влияя на все последующие инструкции(RUN, CMD и ENTRYPOINT).
    Шаблоны ввода:
    • ["<исполняемый файл>", "<параметры>"...]
Инструкция SHELL в частности полезна в Windows где есть две совершенно разных оболочки: cmd и powershell, а также альтернативные включая sh и Linux для переключения на альтернативные оболочки вроде zsh, csh, tcsh и т.д.

Команды:
docker attach <имя контейнера> - присоединить локальные потоки ввода, вывода и ошибок к работающему контейнеру
docker build <url> - собрать образ контейнера из url
docker build . - собрать образ контейнера из Dockerfile в текущем каталоге
    -t <тэг> - добавить тэг образу
    -f <Dockerfile> - явно указать определенный Dockerfile
    --build-arg <ключ>=<значение> - передать аргумент в инструкцию ARG Dockerfile'а (можно через env)
    --add-host=<имя хоста>:<ip> - добавить хоста в /etc/hosts образа
    --target <имя таргета> - выбрать часть Dockerfile, которая должна выполниться (когда используется FROM ... AS <таргет>)
    --squash - сливает все слои образа в один
.dockerignore - тоже самое что и gitignore только для команды docker build
docker checkpoint create <имя контейнера> <имя контрольной точки> - создать контрольную точку (что-то типа снимка состояния, но только диска без оперативки)
docker commit <id контейнера>  <имя образа>:<тэг> - создание образа из работающего контейнера
    --change "<изменение>" - изменить конфигурацию создаваемого образа (например инструкции CMD, EXPOSE или ENV)
docker context create  --from <имя контекста> <имя контекста> - создать контекст из существующего контекста
docker context create  --docker url="<url>" <имя контекста> - создать контекст из url
docker context create <имя контекста> - создать контекст из текущего контекста
docker context use <имя контекста> - использовать выбранный контекст
docker cp <путь> <имя контейнера>:<путь> - скопировать файл с локальной машины в контейнер
docker cp <имя контейнера>:<путь> <путь> - скопировать файл с контейнера на локальную машину
docker create  --name=<имя контейнера> <имя образа> - создать контейнер
    -v - добавить постоянный том из локальной машины
docker diff <id контейнера> - список изменений в файлах или каталогах в файловой системе контейнера
docker events - просмотр происходящих событий
    --since '<дата>' - с определенного момента
    --until '<дата>' - до определенного момента
    -f <ключ>=<значение> - фильтрация вывода
    --format '<формат>' - форматирование вывода (например {{json .}} для json вывода или <столбец>={{.<ключ>}} для вывода определенных столбцов)
docker exec -d <имя контейнера> <команда> - выполнение команды в контейнере
    -e <ключ>=<значение> - задать env пересенную
    -w <каталог> - задать стартовый каталог
docker exec -it <имя контейнера> sh - захват консоли контейнера
docker export -o <имя архива> <имя контейнера>- создать снимок файловой системы контейнера (без томов)
docker history <имя образа> - просмотр списка действий произошедших с образом (можно добавить тэг)
    --format '<формат>' - форматирование вывода
docker images - список последних созданных образов
    --no-trunc - не обрезать вывод
    -f <ключ>=<значение> - фильтрация вывода
    --format '<формат>' - форматирование вывода
    --format json - в  виде json
docker images <репозиторий> - список образов определенного репозитория (можно добавить тэг)
docker import <архив> - создание образа из архива полученного с помощью docker export
docker info - информация о Docker
docker init - создание файлов (.dockerignore, Dockerfile и docker-compose.yaml) в папке проекта
docker inspect  --type=<тип объекта> <имя объекта> - получение информации об объекте Docker
    --size - размер
    --format '<формат>' - форматирование вывода
docker kill <имя контейнера> - отправление KILL сигнала контейнеру
    --signal=<сигнал> - явно указать сигнал
docker load  --input <архив> - создание образа из архива полученного с помощью docker save
docker login  --username <логин>  --password <пароль> - авторизация в репозитории, указанном в контексте
docker logout - выйти из репозитория, указанного в контексте
docker logs <имя контейнера> - показать логи контейнера
    --details - детализированные
    -f - в реальном времени
    --since '<дата>' - с определенного момента
    --until '<дата>' - до определенного момента
    --tail <количество> - определенное количество строк с конца
docker pause <имя контейнера> - остановка процессов в контейнере
docker port <имя контейнера> - список проброшенных портов контейнера
docker ps - список запущенных контейнеров
    --no-trunc - не обрезать вывод
    -a - все контейнеры
    --size - показывать размер
    -f <ключ>=<значение> - фильтрация вывода
    --format '<формат>' - форматирование вывода
docker pull <имя образа> - скачать образ из DockerHub (можно добавить тэг)
docker pull <имя образа> - загрузить образ на DockerHub (можно добавить тэг)
docker rename <имя контейнера> <новое имя контейнера> - переименовать контейнер
docker restart <имя контейнера> - перезапустить контейнер
docker rm <имя контейнера> - удалить контейнер
    -f - с помощью сигнала KILL
    -v - вместе с прикрепленными томами
docker rm $(docker ps  --filter status=exited -q) - удалить все неработающие контейнеры
docker rmi <имя образа> - удалить образ
    -f - даже если есть рабочие контейнеры этого образа
docker run  --name <имя контейнера> <имя образа> - запустить контейнер
    --privileged - выдать права локального устройства контейнеру
    -w <каталог> - задать рабочий каталог
    --storage-opt size=<размер> - задать размер диска
    -v <локальный каталог>:<каталог контейнера> - смонтировать локальный каталог в контейнер
    --read-only - смонтировать только для чтения
    --mount type=bind,src=<локальный каталог>,dst=<каталог контейнера> - тоже самое что и -v только более подробно
    -p <локальный порт>:<порт контейнера>/<протокол> - проброс портов контейнера
    --expose <порт контейнера> - открыть порт контейнера без пробрасывания на локальный порт
    --pull=never - не скачивать образ из репозитория, даже если его нет в кэше
    --pull=missing - скачивать только те части образа, которых нет в кэше
    --pull=always - все скачивать образ, даже если он есть в кэше
    --env <ключ>=<значение> - задать переменные окружения
    --env-file <файл> - взять переменный окружения из файла
    --label <ключ>=<значение> - задать метки
    --label-file <файл> - взять мети из файла
    --network <имя сети> - присоединить к сети
    --ip=<ip адрес> - задать ip адрес в сети
    --volumes-from <id контейнера>:<тип доступа> - смонтировать тома другого контейнера
    --device <имя локального девайса>:<имя девайса контейнера> - присоединить локальный девайс контейнеру
    --gpus device=<id GPU> - подключить GPU контейнеру
    --restart=no - никогда не перезапускать контейнер
    --restart=on-failure[:<количество рестартов>] - перезапускать контейнер только при ошибке
    --restart=unless-stopped - всегда перезапускать контейнер, кроме случаев когда использована команда docker stop
    --restart=always - всегда перезапускать контейнер
    --add-host=<имя хоста>:<ip> - добавить хоста в /etc/hosts контейнера
    --stop-signal <сигнал> - задать значение сигнала KILL
    -m <объем RAM> - задать объем оперативной памяти
    --sysctl <ключ>=<значение> - конфигурирование sysconfig
docker save  --output <имя архива> <имя образа> - создание архива из образа
docker search <имя образа> - поиск образа в Docker Hub
    --limit <количество> - количество выводимых строк
    -f <ключ>=<значение> - фильтрация вывода
    --format '<формат>' - форматирование вывода
docker network create -d <сетевой драйвер> <имя сети> - создание сети для контейнеров
    --subnet=<сеть/маска> - задать подсеть
    --ip-range=<диапазон ip адресов> - задать диапазон ip адресов
    --gateway=<ip адрес шлюза> - задать дефолтный шлюз
    --attachable - можно подключаться к сети при создании контейнера
    --aux-address="<устройство>=<ip адрес>" - резервация ip адреса
docker secret create <имя секрета> <файл> - создать секрет
    --label <ключ>=<значение> - задать метку
docker start <имя контейнера> - запустить контейнер
docker stats <имя/id контейнера> <имя/id контейнера> - статистика по данным контейнерам в реальном времени
    -a - по всем контейнерам
    --format '<формат>' - форматирование вывода
    --no-stream - отключить отображение в реальном времени
docker stop <имя контейнера> - остановить контейнер
docker system df - общая информация об использовании диска
    -v - подробно
docker system prune - удалить все неиспользуемые контейнеры, образы, сети и очистить кэш
    -f - не запрашивать подтверждения
    -v - удалить неиспользуемые тома
    -f <ключ>=<значение> - фильтрация вывода
    -a - образы не использующиеся напрямую (те которые использовались для создания других образов)
docker tag <имя образа> <репозиторий>/<имя>:<тэг> - задать тэг образу
docker top <имя контейнера> - список процессов контейнера
docker unpause <имя контейнера> - снять контейнер с паузы (команда docker pause)
docker update <параметр> <имя контейнера> - изменить параметры контейнера
docker version - версия Docker
    --format '<формат>' - форматирование вывода
docker volume create <имя тома> - создать постоянный том
    --driver <драйвер> - задать драйвер
    --opt <ключ>=<значение> - задать опции для драйвера